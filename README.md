
### Reflection 1

#### You already implemented two new features using Spring Boot. Check again your source code and evaluate the coding standards that you have learned in this module. Write clean code principles and secure coding practices that have been applied to your code.  If you find any mistake in your source code, please explain how to improve your code. Please write your reflection inside the repository's README.md file.

The coding standards that I have learned and implemented in this exercise are readability, reliability and reusability. By using a UUID for product id's during product creation, the program becomes more reliable and secure because the id's are unique and not simply enumerated by incrementing the value. This also helps the product become more reusable when implementing editing and deletion because we can simply fetch the UUID of the product that we want to edit/delete. I also did my best to make the code readable by putting simple, descriptive names for the variables. In addition, I keep the formatting consistent with the same amount of coding style and indentation. The functions are also kept short and concise so that they only focus on a single task. 

### Reflection 2

#### After writing the unit test, how do you feel? How many unit tests should be made in a class? How to make sure that our unit tests are enough to verify our program? It would be good if you learned about code coverage. Code coverage is a metric that can help you understand how much of your source is tested. If you have 100% code coverage, does that mean your code has no bugs or errors?

After writing the unit test, I feel relieved because I put in a lot of work into configuring how they work. We can make sure that our unit tests are enough to verify our program by writing separate unit cases for the failures and successes of each of our functions. To help with this, we can use certain tools to receive a metric called code coverage, which helps to check what percentage of lines in our program is covered by our unit tests. For example, a 50% code coverage means that 50% of the lines in our program are covered by our unit tests. Even if we have 100% code coverage for example, our code may still have bugs and errors. Code coverage only measures the percentage of code that is executed by tests, but it does not check whether the tests can catch all the possible issues with our code. It also doesn't help in measuring the quality of our code, plus logic errors and edge cases might still go unnoticed.

#### Suppose that after writing the CreateProductFunctionalTest.java along with the corresponding test case, you were asked to create another functional test suite that verifies the number of items in the product list. You decided to create a new Java class similar to the prior functional test suites with the same setup procedures and instance variables. What do you think about the cleanliness of the code of the new functional test suite? Will the new code reduce the code quality? Identify the potential clean code issues, explain the reasons, and suggest possible improvements to make the code cleaner! Please write your reflection inside the repository's README.md file.
